<!doctype html>
<html>

<head>
    <title>Demineur 3D</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="js/three.min.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/MTLLoader.js"></script>
</head>

<body>
    <div id="container"></div>
    <script>
        var oldWarnFunction = console.warn;
        console.warn = function(){};
        var o
        var cubeSize=5
        var isMouseDown = false;
        if (!Detector.webgl) Detector.addGetWebGLMessage();
        var mouse = new THREE.Vector2();
        raycaster = new THREE.Raycaster();
        var camera, controls, scene, renderer,INTERSECTED,stats,triangle1,deltaX,deltaY;
        //var targetList = [];
        init();
        animate();
        function onMouseMove(event){
            event.preventDefault();
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            deltaX+=mouse.x
            deltaY+=mouse.y
        }
        function onMouseDown(){
            isMouseDown = true;
            deltaX=0
            deltaY=0
        }
        function init() {
            
            //basics
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xcccccc, 0.0005);
            renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(scene.fog.color);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            var container = document.getElementById('container');
            container.appendChild(renderer.domElement);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.z = 100;
            camera.position.y = 0;
            camera.position.x=0;
            //controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render);
            controls.enableZoom = true;
            controls.target.set(cubeSize*5/2,cubeSize*5/2,cubeSize*5/2)
            controls.autoRotate = true
            //light
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(1, 1, 1);
            scene.add(light);
            light = new THREE.DirectionalLight(0xffffff);
            light.position.set(-1, -1, -1);
            scene.add(light);
            light = new THREE.AmbientLight(0x222222);
            scene.add(light);
            //construction
            // Cube
            var group= new THREE.Geometry();
            var texture = new THREE.TextureLoader().load( "normal.png" );
            var materials = [
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors}),
                
            ]
            materials.needsUpdate = true;
            
            
            for (v=0;v<cubeSize;v++){
                for (u=0;u<cubeSize;u++){
                    for (o=0;o<cubeSize;o++){
                        var cubeSide=new THREE.MultiMaterial( materials )
                        var geometry = new THREE.BoxGeometry( 5, 5, 5 );
				        var cube = new THREE.Mesh( geometry, cubeSide);
				        cube.position.y=5*o;
                        cube.position.x=5*u;
                        cube.position.z=5*v;
                        cube.castShadow=true;
                        cube.receiveShadow=true;
                        cube.name=v*cubeSize*cubeSize+u*cubeSize+o
                        //cube.id=v*cubeSize*cubeSize+u*cubeSize+o
                        //cube.updateMatrix();
                        scene.add(cube)
                        //group.merge( cube.geometry, cube.matrix);                        
                    }
                }
            }
            //scene.add(new THREE.Mesh(group,cubeSide));
            //options
            stats = new Stats();
            container.appendChild(stats.dom);
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener( 'mousemove', onMouseMove);
            window.addEventListener("click",itsAMoove)
            
            
        }
        
        function itsAMoove(){
            
            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( scene.children );
            // if there is one (or more) intersections
            if (intersects.length > 0 && (Math.abs(deltaX)<1 && Math.abs(deltaY)<1)) {
                // if the closest object intersected is not the currently stored intersection object
                if (intersects[0].object != triangle1) {
                    triangle1 = intersects[0].object;
                    currentId=triangle1.name
                    currentPosition=triangle1.position
                    console.log(currentId,currentPosition)
                    var texture = new THREE.TextureLoader().load( "changed.png" );
                    triangle1.material=new THREE.MeshBasicMaterial({map: texture, vertexColors: THREE.FaceColors})
                    var mtlLoader = new THREE.MTLLoader();
                    mtlLoader.load('bomb.mtl', function(materials) {
                        materials.preload();
				        var loader = new THREE.OBJLoader();
                        loader.setMaterials(materials);
				        loader.load( 'bomb.obj', function ( object ) {
                            scene.remove(triangle1)
                            scene.add(object)
                            object.position.copy(currentPosition)
                            object.position.y-=1
                            console.log(object)
                            object.scale.set(0.2,0.2,0.2)
				        });
                    });
                    /* comment j'aurais calculer des vertices
                    var vertices = triangle1.geometry.vertices;
                    var v1 = vertices[face.a];
                    var v2 = vertices[face.b];
                    var v3 = vertices[face.c];
                    var position = new THREE.Vector3();
                    position.x = (v1.x + v3.x) / 2;
                    position.y = (v1.y  +v3.y) / 2;
                    position.z = (v1.z+ v3.z) / 2;*/
                }
            }
            else {
                triangle1 = null;                
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isMouseDown){
            controls.update(); }
            stats.update();
            render();
        }

        function render() {
            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( scene.children );
            // if there is one (or more) intersections
            if (intersects.length > 0) {
                // if the closest object intersected is not the currently stored intersection object
                if (intersects[0].object != INTERSECTED) {
                    // Restore previous intersection objects (if they exist) to their original color
                    if (INTERSECTED) {
                        for (p=0;p<12;p++){
                            INTERSECTED.object.geometry.faces[p].color.setHex(INTERSECTED.currentHex);
                        }
                        INTERSECTED.object.geometry.colorsNeedUpdate = true;
                    }
                    
                    INTERSECTED = intersects[0];
                    
                    var geometry = INTERSECTED.object.geometry;
                    INTERSECTED.currentHex = INTERSECTED.face.color.getHex();
                    for (p=0;p<12;p++){
                        geometry.faces[p].color.setHex(0xc0392b);
                    }
                    //console.log(INTERSECTED.currentHex)
                    geometry.colorsNeedUpdate = true;
                    isMouseDown=true;
                }
            }
            else {
                // restore previous intersection object (if it exists) to its original color
                if (INTERSECTED) {
                    for (p=0;p<12;p++){
                        INTERSECTED.object.geometry.faces[p].color.setHex(INTERSECTED.currentHex);
                        
                    }
                    INTERSECTED.object.geometry.colorsNeedUpdate = true;
                } 
                INTERSECTED = null;
                isMouseDown=false;
            }      
            renderer.render(scene, camera);
            
        }
        function renders(){
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
<script type="text/javascript" src="js/brython.js"></script>
<script type="text/javascript" src="js/brython_stdlib.js"></script>
<script>
    function waitForIt() {
        setTimeout(function () {
            h = confirm("Tu as perdu, veux-tu recommencer?")
            if (h) {
                location.reload(true)
            }
        }, 500);
    }
    setTimeout(function(){
        localStorage.clear()
        brython({debug:1, cache:'none'})
    },1)
    
</script>
<script type="text/python3">
from browser import window,console,confirm
from browser.local_storage import storage
from browser.object_storage import ObjectStorage
import random
tailleCube=5
#sys.setrecursionlimit(2000)
object_storage = ObjectStorage(storage)
    
pos = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1), (0, 0)]
grille3D = [[[0] * tailleCube for i in range(tailleCube)] for j in range(tailleCube)]
revele = [[[0] * tailleCube for i in range(tailleCube)] for j in range(tailleCube)]
final=[[[0] * tailleCube for i in range(tailleCube)] for j in range(tailleCube)]


# functions
def onclick(x, y):
    try:
        if grille[y][x] == "*":
            return 1
        if grille[y][x] != 0:
            revele[y][x] = 1
            return 0
        grille[y][x] = "@"
        revele[y][x] = 1
        for c in pos:
            if x+c[0]>-1:
                if y+c[1]>-1:
                    onclick(x + c[0], y + c[1])
    except:
        pass

def onclickExecuted(x,y):
    u=window.test(y*20+x)
    
    if not int(storage["aut"]) and u:
        
        j=onclick(x,y)
        if j:
            storage["e"]=str(j)
            afficher(grille)
            window.waitForIt()
            return
        afficher(revele)
    else:
        window.putIt(y*20+x)

#logic for placement
def bombe(d):
    x = random.randint(0, tailleCube-1)
    y = random.randint(0, tailleCube-1)
    while grille3D[d][y][x] == "*":
        x = random.randint(0, tailleCube-1)
        y = random.randint(0, tailleCube-1)
    grille3D[d][y][x] = "*"
    number(x, y, d)


def number(x, y,d):
    for c in pos:
        if tailleCube>(y+c[0])>-1 and tailleCube>(c[1]+x) > -1 :
            #grille courante
            if grille3D[d][y + c[0]][x + c[1]] != "*":
                grille3D[d][y + c[0]][x + c[1]] += 1
            #grille en retroaction: base inferieure du cube
            if d>0 and grille3D[d-1][y + c[0]][x + c[1]] != "*" :
                grille3D[d-1][y + c[0]][x + c[1]] += 1
            #grille en proaction: base superieure du cube
            if d<tailleCube-1:
                grille3D[d + 1][y + c[0]][x + c[1]] += 1

#python output
def output(g):
    for col in g: print(" ".join(map(str, col)))
    
def outputFace(g):
    for j in range(tailleCube):
        for i in range(tailleCube):
            print(" ".join(map(str, g[j][i])))
        print()       

    
#main 
def main():
    for i in range(tailleCube):
        for loop in range(int(tailleCube*tailleCube*0.05)):
            bombe(i)
    object_storage["grille"]=grille3D
main()
window.mouvementDemineur = onclickExecuted
    

</script>