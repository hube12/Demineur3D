<!doctype html>
<html>

<head>
    <title>Demineur 3D</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="js/three.min.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/MTLLoader.js"></script>
</head>

<body>
    <div id="container"></div>
    <script>
        var saveE=[];
        var cubeSize=10;
        var isMouseDown = false;
        if (!Detector.webgl) Detector.addGetWebGLMessage();
        var mouse = new THREE.Vector2();
        raycaster = new THREE.Raycaster();
        var camera, controls, scene, renderer,INTERSECTED,stats,triangle1,deltaX,deltaY;
        //var targetList = [];
        init();
        function onMouseMove(event){
            event.preventDefault();
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            deltaX+=mouse.x
            deltaY+=mouse.y
        }
        function onMouseDown(){
            isMouseDown = true;
            deltaX=0
            deltaY=0
        }
        function getRandomColor() {
            var letters = '0123456789abcdef';
            var color = '0x';
            for (var i = 0; i < 6; i++ ) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return parseInt(color,16);
        }
        var mapColor=[]
        for (h=0;h<26;h++){
            mapColor.push(getRandomColor())
        }
        function init() {
            
            //basics
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xcccccc, 0.002);
            renderer = new THREE.WebGLRenderer();
            renderer.setClearColor(scene.fog.color);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            var container = document.getElementById('container');
            container.appendChild(renderer.domElement);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 140;
            camera.position.y = 0;
            camera.position.x=0;
            //controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render);
            controls.enableZoom = true;
            controls.target.set(cubeSize*5/2,cubeSize*5/2,cubeSize*5/2)
            controls.autoRotate = true
            //light
            light = new THREE.DirectionalLight(0xA9ADB5,0.6);
            light.position.set(100, 100, 100);
            scene.add(light);
            light = new THREE.DirectionalLight(0xA9ADB5,0.6);
            light.position.set(-100, -100, -100);
            scene.add(light);
            light = new THREE.AmbientLight(0x222222,0.9);
            scene.add(light);
            //construction
            // Cube
            var group= new THREE.Geometry();
            var texture = new THREE.TextureLoader().load( "normal.png" );
            /*var materials = [
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors, opacity:0.8, transparent:true}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors, opacity:0.8, transparent:true}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors, opacity:0.8, transparent:true}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors, opacity:0.8, transparent:true}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors, opacity:0.8, transparent:true}),
                new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors, opacity:0.8, transparent:true})  
            ]*/
            material=new THREE.MeshStandardMaterial( { map: texture, vertexColors: THREE.FaceColors, opacity:0.8, transparent:true}),
            material.needsUpdate = true;
            
            
            for (v=0;v<cubeSize;v++){
                for (u=0;u<cubeSize;u++){
                    for (o=0;o<cubeSize;o++){
                        //var cubeSide=new THREE.MultiMaterial( materials )
                        var geometry = new THREE.BoxGeometry( 5, 5, 5 );
				        var cube = new THREE.Mesh( geometry, material);
				        cube.position.y=5*o;
                        cube.position.x=5*u;
                        cube.position.z=5*v;
                        cube.castShadow=true;
                        cube.receiveShadow=true;
                        cube.name=v*cubeSize*cubeSize+u*cubeSize+o
                        //console.log(cube.name)
                        //cube.id=v*cubeSize*cubeSize+u*cubeSize+o
                        //cube.updateMatrix();
                        scene.add(cube)
                        //group.merge( cube.geometry, cube.matrix);                        
                    }
                }
            }
            //scene.add(new THREE.Mesh(group,cubeSide));
            //options
            stats = new Stats();
            container.appendChild(stats.dom);
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener( 'mousemove', onMouseMove);
            window.addEventListener("click",itsAMoove)
            animate();
            var loader = new THREE.FontLoader();
        loader.load( 'fonts/helvetiker_regular.typeface.json',function(f){
            window.fonty=f
        })
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.load('bomb.mtl', function(materials) {
                        materials.preload();
				        var loader = new THREE.OBJLoader();
                        loader.setMaterials(materials);
				        loader.load( 'bomb.obj', function ( object ) {
                            window.objectify=object}
                                    )});
            
        }
        function bombIt(o){
            object=objectify.clone()
                            p=o.position
                            scene.remove(o)
                            scene.add(object)
                            object.position.copy(p)
                            object.position.y-=1
                            object.scale.set(0.2,0.2,0.2)
				       
        }
        function itsTheFinal(o,p){
            for (i=0;i<cubeSize;i++){
                for (j=0;j<cubeSize;j++){
                    for (k=0;k<cubeSize;k++){
                        var actuel=grille[i][j][k]
                        var objetEnQuestion= scene.getObjectByName((i*cubeSize+j)*cubeSize+k)
                        if (objetEnQuestion!=null){
                        if (actuel=="*"){
                            
                            bombIt(objetEnQuestion)
                            
                            //bombIt(oposm)
                        }
                        else if(actuel=="0"){
                            scene.remove(objetEnQuestion)
                        }
                        else{
                            numberIt(objetEnQuestion,actuel)
                        }
                    }}
                }
            }
        }
        function numberIt(o,nbr){
            
                var textGeo = new THREE.TextGeometry( nbr, {
                    size: 2,
                    font: fonty,
                    height:0.5
                    
                });
                var material = new THREE.MeshBasicMaterial({color: mapColor[nbr-1]});
                var textGeo = new THREE.Mesh(textGeo, material); 
                
                p=o.position;
                scene.remove(o);
                scene.add(textGeo);
                textGeo.position.copy(p)
                textGeo.position.x-=1
                textGeo.lookAt(camera.position)
                saveE.push(textGeo);
            
            
        }
        function itsAMoove(){
            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( scene.children );
            // if there is one (or more) intersections
            if (intersects.length > 0 && (Math.abs(deltaX)<1 && Math.abs(deltaY)<1)) {
                // if the closest object intersected is not the currently stored intersection object
                if (intersects[0].object != triangle1) {
                    triangle1 = intersects[0].object;
                    currentId=triangle1.name
                    currentPosition=triangle1.position;
                    grille=JSON.parse(localStorage.getItem('"grille"'));
                    currentMoove=grille[Math.floor(currentId/(cubeSize*cubeSize))][Math.floor((currentId%(cubeSize*cubeSize))/cubeSize)][(currentId%(cubeSize*cubeSize))%cubeSize]
                    if (currentMoove=="*"){
                        itsTheFinal(triangle1,currentPosition)
                    }
                    else if (currentMoove=="0"){
                        revealIt(currentPosition)
                        scene.remove(triangle1)
                    }
                    else{
                        numberIt(triangle1,currentMoove)
                    }
                    //new RegExp(^(0|[1-9][0-9]*)$)
                    //var texture = new THREE.TextureLoader().load( "changed.png" );
                    //triangle1.material=new THREE.MeshBasicMaterial({map: texture, vertexColors: THREE.FaceColors})
                    
                    /* comment j'aurais calculer des vertices
                    var vertices = triangle1.geometry.vertices;
                    var v1 = vertices[face.a];
                    var v2 = vertices[face.b];
                    var v3 = vertices[face.c];
                    var position = new THREE.Vector3();
                    position.x = (v1.x + v3.x) / 2;
                    position.y = (v1.y  +v3.y) / 2;
                    position.z = (v1.z+ v3.z) / 2;*/
                }
            }
            else {
                triangle1 = null;                
            }
        }
        function onWindowResize() {
            console.log(fonty,objectify)
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isMouseDown){
            controls.update(); }
            stats.update();
            //console.clear()
            render();
        }

        function render() {
            raycaster.setFromCamera( mouse, camera );
            var intersects = raycaster.intersectObjects( scene.children );
            // if there is one (or more) intersections
            if (intersects.length > 0) {
                // if the closest object intersected is not the currently stored intersection object
                if (intersects[0].object != INTERSECTED) {
                    // Restore previous intersection objects (if they exist) to their original color
                    if (INTERSECTED) {
                        for (p=0;p<12;p++){
                            INTERSECTED.object.geometry.faces[p].color.setHex(INTERSECTED.currentHex);
                        }
                        INTERSECTED.object.geometry.colorsNeedUpdate = true;
                    }
                    
                    INTERSECTED = intersects[0];
                    
                    var geometry = INTERSECTED.object.geometry;
                    INTERSECTED.currentHex = INTERSECTED.face.color.getHex();
                    for (p=0;p<12;p++){
                        geometry.faces[p].color.setHex(0xc0392b);
                    };
                    geometry.colorsNeedUpdate = true;
                    isMouseDown=true;
                }
            }
            else {
                // restore previous intersection object (if it exists) to its original color
                if (INTERSECTED) {
                    for (p=0;p<12;p++){
                        INTERSECTED.object.geometry.faces[p].color.setHex(INTERSECTED.currentHex);
                        
                    }
                    INTERSECTED.object.geometry.colorsNeedUpdate = true;
                } 
                INTERSECTED = null;
                isMouseDown=false;
            }
            
            saveE.forEach(function(el){
                el.lookAt(camera.position)
            })
            renderer.render(scene, camera);
            
        }
        function renders(){
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
<script type="text/javascript" src="js/brython.js"></script>
<script type="text/javascript" src="js/brython_stdlib.js"></script>
<script>
    function waitForIt() {
        setTimeout(function () {
            h = confirm("Tu as perdu, veux-tu recommencer?")
            if (h) {
                location.reload(true)
            }
        }, 500);
    }
    setTimeout(function(){
        localStorage.clear()
        brython({debug:1, cache:'none'})
        
        
    },1)
    function hackIt(){
        var oldWarnFunction = console.warn;
        console.warn = function(){};
        var oldError=console.error;
        console.error=function(){};
        console.debug=function(){};
        console.assert=function(){};
        console.clear=function(){};
        console.exception=function(){};
        console.info=function(){};
        console.trace=function(){};
        console.group=function(){};
        //console.log=function(){};
    }
    
</script>
<script type="text/python3">
from browser import window,console,confirm
from browser.local_storage import storage
from browser.object_storage import ObjectStorage
import random
tailleCube=10
#sys.setrecursionlimit(2000)
object_storage = ObjectStorage(storage)
    
pos = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1), (0, 0)]
grille3D = [[[0] * tailleCube for i in range(tailleCube)] for j in range(tailleCube)]
revele = [[[0] * tailleCube for i in range(tailleCube)] for j in range(tailleCube)]
final=[[[0] * tailleCube for i in range(tailleCube)] for j in range(tailleCube)]


# functions
def onclick(x, y):
    try:
        if grille[y][x] == "*":
            return 1
        if grille[y][x] != 0:
            revele[y][x] = 1
            return 0
        grille[y][x] = "@"
        revele[y][x] = 1
        for c in pos:
            if x+c[0]>-1:
                if y+c[1]>-1:
                    onclick(x + c[0], y + c[1])
    except:
        pass

def onclickExecuted(x,y):
    u=window.test(y*20+x)
    
    if not int(storage["aut"]) and u:
        
        j=onclick(x,y)
        if j:
            storage["e"]=str(j)
            afficher(grille)
            window.waitForIt()
            return
        afficher(revele)
    else:
        window.putIt(y*20+x)

#logic for placement
def bombe(d):
    x = random.randint(0, tailleCube-1)
    y = random.randint(0, tailleCube-1)
    while grille3D[d][y][x] == "*":
        x = random.randint(0, tailleCube-1)
        y = random.randint(0, tailleCube-1)
    grille3D[d][y][x] = "*"
    number(x, y, d)
def revealIt(p):
    x=p.x

def number(x, y,d):
    for c in pos:
        if tailleCube>(y+c[0])>-1 and tailleCube>(c[1]+x) > -1 :
            #grille courante
            if grille3D[d][y + c[0]][x + c[1]] != "*":
                grille3D[d][y + c[0]][x + c[1]] += 1
            #grille en retroaction: base inferieure du cube
            if d>0 and grille3D[d-1][y + c[0]][x + c[1]] != "*" :
                grille3D[d-1][y + c[0]][x + c[1]] += 1
            #grille en proaction: base superieure du cube
            if d<tailleCube-1:
                grille3D[d + 1][y + c[0]][x + c[1]] += 1

#python output
def output(g):
    for col in g: print(" ".join(map(str, col)))
    
def outputFace(g):
    for j in range(tailleCube):
        for i in range(tailleCube):
            print(" ".join(map(str, g[j][i])))
        print()       

    
#main 
def main():
    for i in range(tailleCube):
        for loop in range(int(tailleCube*tailleCube*0.15)):
            bombe(i)
    object_storage["grille"]=grille3D
main()
window.revealIt = revealIt
    

</script>